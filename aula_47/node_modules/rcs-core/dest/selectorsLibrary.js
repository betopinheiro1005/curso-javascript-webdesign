"use strict";

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SelectorsLibrary = void 0;

const attributeLibrary_1 = require("./attributeLibrary");

const idSelectorLibrary_1 = __importDefault(require("./idSelectorLibrary"));

const classSelectorLibrary_1 = __importDefault(require("./classSelectorLibrary"));

const baseLibrary_1 = require("./baseLibrary");

const arrayToRegex_1 = __importDefault(require("./helpers/arrayToRegex")); // Simple aggregate class to avoid duplicating code dealing with any CSS selector.


class SelectorsLibrary extends baseLibrary_1.BaseLibrary {
  constructor() {
    super(...arguments);
    this.selectors = [idSelectorLibrary_1.default, classSelectorLibrary_1.default];
  } // chain function call with unknown arguments, make our live easier
  // eslint-disable-next-line @typescript-eslint/no-explicit-any


  callOnBoth(fun, ...args) {
    const result = this.selectors.reduce((prev, sel) => {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      const fn = sel[fun];

      if (typeof fn === 'function') {
        const res = fn.apply(sel, args); // The number of case where the function is returning something is low and
        // per function specific. Don't be too smart, the caller know betters than us.

        return [...prev, res];
      }

      return prev;
    }, []);
    return result;
  }

  reset() {
    this.callOnBoth('reset');
  }

  setAlphabet(...args) {
    this.callOnBoth('setAlphabet', ...args);
  }

  getClassSelector() {
    return this.selectors[1];
  }

  getIdSelector() {
    return this.selectors[0];
  }

  fillLibrary(...args) {
    this.callOnBoth('fillLibrary', ...args);
  }

  set(...args) {
    this.callOnBoth('set', ...args);
  }

  setMultiple(...args) {
    this.callOnBoth('setMultiple', ...args);
  }

  setPrefix(...args) {
    this.callOnBoth('setPrefix', ...args);
  }

  setSuffix(...args) {
    this.callOnBoth('setSuffix', ...args);
  }

  getSuffix() {
    return this.selectors[0].suffix;
  }

  getPrefix() {
    return this.selectors[0].prefix;
  }

  setExclude(...args) {
    this.callOnBoth('setExclude', ...args);
  }

  setInclude(...args) {
    this.callOnBoth('setInclude', ...args);
  }

  setReserved(...args) {
    this.callOnBoth('setReserved', ...args);
  }

  setAttributeSelector(data) {
    if (Array.isArray(data)) {
      data.forEach(value => this.setAttributeSelector(value));
      return;
    }

    this.selectors.forEach(sel => {
      const matches = data.match(sel.getAttributeSelectorRegex());

      if (matches) {
        sel.setAttributeSelector(matches);
      }
    });
  }

  replaceAttributeSelector(selector) {
    let ret = false;
    this.selectors.forEach(sel => {
      if (sel.isValidSelector(selector)) {
        const res = sel.replaceAttributeSelector(selector);
        ret = res ? sel.selectorFirstChar() + res : res;
      }
    });
    return ret;
  } // With return values, specific logic


  getAllRegex(opts = {}) {
    const options = Object.assign({
      regex: true
    }, opts);
    const ret = this.callOnBoth('getAll', options); // null assertion to keep the same functionality
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion

    return (0, arrayToRegex_1.default)(ret.filter(Boolean).map(x => x.source));
  }

  get(value, opts = {}) {
    const stringifyLineBreaks = value.replace(/\n/g, '\\n');
    const [beginningWhitespace] = stringifyLineBreaks.match(/^(\\.| )+/) || [''];
    const [endWhitespace] = stringifyLineBreaks.match(/(\\.| )+$/) || [''];
    const modifiedValue = stringifyLineBreaks.replace(beginningWhitespace, '').replace(endWhitespace, '');
    const hasType = attributeLibrary_1.AttributeLibrary.isSelector(modifiedValue);

    const reconstructValue = v => (beginningWhitespace + v + endWhitespace).replace(/\\n/g, '\n');

    if (!hasType) {
      const ret = this.selectors[0].get(modifiedValue, opts);
      return reconstructValue(ret === modifiedValue ? this.selectors[1].get(modifiedValue, opts) : ret);
    }

    if (this.selectors[0].isValidSelector(modifiedValue)) {
      return reconstructValue(this.selectors[0].get(modifiedValue, opts));
    }

    return reconstructValue(this.selectors[1].get(modifiedValue, opts));
  } // If it's reserved in any case, consider it reserved everywhere


  isReserved(...args) {
    const ret = this.callOnBoth('isReserved', ...args);
    return ret[0] || ret[1];
  } // If it's excluded in any case, consider it excluded everywhere


  isExcluded(...args) {
    const ret = this.callOnBoth('isExcluded', ...args);
    return ret[0] || ret[1];
  }

}

exports.SelectorsLibrary = SelectorsLibrary;
exports.default = new SelectorsLibrary();