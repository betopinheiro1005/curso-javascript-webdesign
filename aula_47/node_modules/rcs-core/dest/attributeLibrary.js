"use strict";

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AttributeLibrary = void 0;

const postcss_1 = require("postcss");

const regex_1 = __importDefault(require("./replace/regex"));

const excludeList_1 = __importDefault(require("./helpers/excludeList"));

const nameGenerator_1 = require("./nameGenerator");

const baseLibrary_1 = require("./baseLibrary"); // This abstract class implements the attribute parsing and replacing logic
// It has to be specialized for each type (likely class or id), and thus
// any logic of selection (like . or #) is defined in the child class, not this one.


class AttributeLibrary extends baseLibrary_1.BaseLibrary {
  constructor(name) {
    super(name);
    this.attributeSelectors = {}; // Get the selector char for this child class

    this.selectorFirstChar = () => '#';

    this.prefetchValue = selector => selector.replace(/(\.|#)/, '').replace(/\\/g, ''); // Child class will override this to whatever regex that best fit their need
    // For example: form[class*=selector]
    // The regex should have 3 group matches:
    // First: The attribute name ('class' in previous example),
    // Second: The regular expression operator (* in previous example, '' when none)
    // Third: The term used ('selector' in the previous example)


    this.getAttributeSelectorRegex = () => regex_1.default.idAttributeSelectors;

    this.setExclude(excludeList_1.default);
  } // used at many place, let make a single function for this


  static isSelector(selector) {
    return selector.charAt(0) === '.' || selector.charAt(0) === '#';
  }

  static removePseudoElements(value) {
    const splits = value.split(/\\/g);
    const splittedEscapes = splits.map((split, i) => {
      if (splits.length - 1 > i) {
        // returns the normal split
        // as pseudo elements are just at the end
        return split;
      } // remove the first char
      // in case it is a :


      const firstChar = split.charAt(0) || '';
      const modifiedString = split.slice(1); // replace everything with a :
      // this should be a pseudo element

      const removedPseudoElements = modifiedString.replace(/:.+/g, '');
      return firstChar + removedPseudoElements;
    });
    return splittedEscapes.join('');
  }

  static replaceAnAttributeSelector(result, attributeSelector, value, slicedSelector) {
    if (result !== false) return result;
    const attributeString = attributeSelector.slice(1, attributeSelector.length);

    if (attributeSelector.charAt(0) === '|') {
      const match = slicedSelector.match(`^${attributeString}-`);

      if (match) {
        const newMatch = match[0].replace(/-$/, '');
        return `${newMatch}-${value.nameGeneratorCounter.generate(slicedSelector)}`;
      }
    }

    if (attributeSelector.charAt(0).match(/^[=~|]/)) {
      const match = slicedSelector.match(attributeString);

      if (match && slicedSelector === match[0]) {
        return match[0];
      }
    }

    switch (attributeSelector.charAt(0)) {
      case '*':
        {
          const match = slicedSelector.match(attributeString);

          if (match) {
            return value.nameGeneratorCounter.generate(slicedSelector) + match[0] + value.nameGeneratorCounter.generate(slicedSelector);
          }

          break;
        }

      case '^':
        {
          const match = slicedSelector.match(`^${attributeString}`);

          if (match) {
            return match[0] + value.nameGeneratorCounter.generate(slicedSelector);
          }

          break;
        }

      case '$':
        {
          const match = slicedSelector.match(`${attributeString}$`);

          if (match) {
            return value.nameGeneratorCounter.generate(slicedSelector) + match[0];
          }

          break;
        }

      default:
        break;
    }

    return false;
  }

  reset() {
    super.reset();
    this.attributeSelectors = {};
    this.setExclude(excludeList_1.default);
  }

  fillLibrary(data, options = {}) {
    const code = data.toString();
    const result = (0, postcss_1.parse)(code); // todo jpeer: check postcss types

    result.walk(root => {
      const parentName = root.parent.name || '';

      if (root.selector && !parentName.match(/keyframes/)) {
        const matchedSelectors = root.selector.match(regex_1.default.selectors) || [];
        this.set(matchedSelectors, options);
      }
    });
  }

  isValidSelector(selector) {
    return selector.charAt(0) === this.selectorFirstChar();
  } // Prepare the value to store in the mapping


  prepareValue(repObj, options = {}) {
    const replacedObject = Object.assign({}, repObj);

    if (!this.isValidSelector(replacedObject.value)) {
      return null;
    }

    const escapeFreeSelector = AttributeLibrary.removePseudoElements(replacedObject.value); // checks if this value was already set

    const realSelector = escapeFreeSelector.slice(1, escapeFreeSelector.length);

    if (!options.ignoreAttributeSelectors) {
      const newName = this.replaceAttributeSelector(escapeFreeSelector);

      if (newName) {
        replacedObject.renamedValue = newName;
      }
    }

    if (replacedObject.renamedValue !== undefined && AttributeLibrary.isSelector(replacedObject.renamedValue)) {
      replacedObject.renamedValue = replacedObject.renamedValue.slice(1, replacedObject.renamedValue.length);
    }

    replacedObject.value = realSelector;
    return replacedObject;
  } // todo jpeer: #104 remove any


  postfetchValue(result, opts) {
    const options = Object.assign({
      addSelectorType: false
    }, opts);
    return (options.addSelectorType ? this.selectorFirstChar() : '') + this.prefix + result + this.suffix;
  }

  getAll(opts = {}) {
    let originalSelector;
    let compressedSelector;
    let resultArray = [];
    let result = {};
    const selectors = this.values;
    const options = Object.assign({
      getRenamedValues: false,
      regex: false,
      addSelectorType: false
    }, opts);
    Object.keys(selectors).forEach(selector => {
      compressedSelector = selectors[selector];
      originalSelector = selector;

      if (options.getRenamedValues) {
        // save compressedSelectors
        result[compressedSelector] = originalSelector;
        resultArray.push(compressedSelector);
      } else {
        // save originalSelectors
        result[selector] = compressedSelector;
        resultArray.push(originalSelector);
      }
    }); // sort array by it's length to avoid e.g. BEM syntax

    if (options.regex) {
      resultArray = resultArray.sort((a, b) => b.length - a.length);
    }

    if (options.addSelectorType) {
      resultArray = resultArray.map(value => `${this.selectorFirstChar()}${value}`);
    }

    if (options.regex) {
      const regex = options.addSelectorType ? new RegExp(resultArray.map(v => `\\${v.replace(/\[/, '\\[')}`).join('|'), 'g') // the next MUST be options.regex === true
      : new RegExp(`(\\s|\\${this.selectorFirstChar()})(${resultArray.map(v => v.replace(/\[/, '\\[')).join('|')})[\\s)]`, 'g');
      const regexResult = resultArray.length === 0 ? undefined : regex;
      return regexResult;
    }

    if (options.addSelectorType) {
      const tempResult = {};
      resultArray.forEach(value => {
        const modValue = value.slice(1, value.length);
        tempResult[value] = result[modValue];
      });
      result = tempResult;
    }

    return result;
  }

  setAttributeSelector(attributeSelector) {
    if (!attributeSelector) {
      return;
    }

    if (Array.isArray(attributeSelector)) {
      attributeSelector.forEach(value => this.setAttributeSelector(value));
      return;
    }

    const re = new RegExp(this.getAttributeSelectorRegex());
    const exec = re.exec(attributeSelector);

    if (!exec) {
      return;
    }

    const term = exec[3];
    let attributeSelectorType = exec[2];
    let selector = term; // it is empty if the attribute selector is following: [class=test]

    if (attributeSelectorType === '') {
      attributeSelectorType = '=';
    }

    if (term.charAt(0).match(/"|'/)) {
      selector = term.slice(1, exec[3].length - 1);
    }

    const attributeSelectorKey = attributeSelectorType + selector;
    this.attributeSelectors[attributeSelectorKey] = {
      type: exec[1],
      originalString: attributeSelector,
      regexType: attributeSelectorType,
      nameGeneratorCounter: new nameGenerator_1.NameGenerator('attribute')
    }; // then, we need to replace any original selector that would be matching this rule with a
    // rename that still match the replacement

    Object.keys(this.values).forEach(key => {
      const r = AttributeLibrary.replaceAnAttributeSelector(false, attributeSelectorKey, this.attributeSelectors[attributeSelectorKey], key);

      if (r !== false) {
        const prev = this.values[key];
        this.values[key] = r;
        delete this.compressedValues[prev];
        this.compressedValues[r] = key;
      }
    });
  }

  replaceAttributeSelector(selector) {
    if (!this.isValidSelector(selector)) {
      return false;
    }

    const slicedSelector = selector.replace(/^[.#]/, '');
    return Object.entries(this.attributeSelectors).reduce((a, entry) => AttributeLibrary.replaceAnAttributeSelector(a, entry[0], entry[1], slicedSelector), false);
  }

}

exports.AttributeLibrary = AttributeLibrary;
exports.default = new AttributeLibrary();