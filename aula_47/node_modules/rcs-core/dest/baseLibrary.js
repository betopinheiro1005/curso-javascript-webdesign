"use strict";

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BaseLibrary = void 0;

const nameGenerator_1 = require("./nameGenerator");

const allWarnings_1 = __importDefault(require("./allWarnings"));

class BaseLibrary {
  constructor(name) {
    this.values = {};
    this.compressedValues = {};
    this.reserved = [];
    this.excludes = [];
    this.excludesRegex = [];
    this.includes = [];
    this.includesRegex = [];
    this.prefix = '';
    this.suffix = '';
    this.meta = {}; // Transform the input value for the one that's stored in the map.

    this.prefetchValue = value => value;

    this.nameGenerator = new nameGenerator_1.NameGenerator(name); // do not call this.reset() directly
    // as it will invoke this.reset on SelectorsLibrary as well
    // where this.selectors is not yet available

    this.initReset();
  }

  static hasReservedValue(value, source) {
    allWarnings_1.default.append(value, source, 'compressed');
    return `${value}_conflict`;
  }

  initReset() {
    this.values = {};
    this.compressedValues = {};
    this.reserved = [];
    this.excludes = [];
    this.excludesRegex = [];
    this.includes = [];
    this.includesRegex = [];
    this.prefix = '';
    this.suffix = '';
    this.meta = {};
    this.nameGenerator.reset();
  }

  reset() {
    this.initReset();
  } // extend methods
  // Shortcut method to change the alphabet of our name generator


  setAlphabet(alphabet) {
    this.nameGenerator.setAlphabet(alphabet);
  } // eslint-disable-next-line max-len
  // eslint-disable-next-line class-methods-use-this, no-unused-vars, @typescript-eslint/no-unused-vars, @typescript-eslint/no-empty-function


  fillLibrary(data, options) {} // Prepare a value to storing in the mapping. It can be stripped of pseudo-classes,
  // or modified to fit a shorter equivalent value. By default, returns the input unmodified.
  // The replacementObject must contain 2 keys: value and renamedValue.
  // eslint-disable-next-line class-methods-use-this


  prepareValue( // eslint-disable-next-line no-unused-vars, @typescript-eslint/no-unused-vars
  replacementObject, // eslint-disable-next-line no-unused-vars, @typescript-eslint/no-unused-vars
  opts) {
    return replacementObject;
  } // Transform the fetched value before returning.
  // eslint-disable-next-line max-len
  // eslint-disable-next-line class-methods-use-this, no-unused-vars, @typescript-eslint/no-unused-vars


  postfetchValue(value, opts) {
    return value;
  }

  get(value, opts = {}) {
    const options = Object.assign({
      isOriginalValue: true,
      countStats: true
    }, opts); // We need the selector's without its decoration (for example, "test" for input ".test")

    const finalValue = this.prefetchValue(value); // fail on setted excludes

    if (this.isExcluded(finalValue)) {
      allWarnings_1.default.append(finalValue, opts.source, 'ignoredFound');
      return value;
    }

    if (!this.values[finalValue] && options.isOriginalValue && this.compressedValues[finalValue]) {
      return BaseLibrary.hasReservedValue(value, options.source);
    }

    let found = (finalValue in this.values);
    let result = this.values[finalValue] || finalValue; // change the objects if isOriginalValue are set to false
    // to get information about the compressed values

    if (!options.isOriginalValue) {
      found = finalValue in this.compressedValues;
      result = this.compressedValues[finalValue] || result;
    } // update stats just when isOriginalValue


    if (options.isOriginalValue && options.countStats) {
      if (!this.meta[finalValue]) {
        this.meta[finalValue] = {
          appearanceCount: 0
        };
      }

      this.meta[finalValue].appearanceCount += 1;
    }

    if (!found) {
      return !options.addSelectorType ? finalValue : value;
    }

    return this.postfetchValue(result, options);
  }

  set(value, renamedValue, opts = {}) {
    if (!value) {
      return;
    }

    let options = opts;
    let thisRenamedValue;

    if (typeof renamedValue === 'object') {
      options = renamedValue;
      thisRenamedValue = undefined;
    } else {
      thisRenamedValue = renamedValue;
    }

    if (Array.isArray(value)) {
      value.forEach(item => this.set(item, thisRenamedValue, options));
      return;
    }

    const repObj = this.prepareValue({
      value,
      renamedValue: thisRenamedValue
    }, options);

    if (!repObj) {
      return;
    } // skip excludes


    if (this.isExcluded(repObj.value)) {
      return;
    } // checks if this value was already set


    if (this.values[repObj.value]) {
      return;
    }

    if (options.preventRandomName === true) {
      this.values[repObj.value] = repObj.value;
      this.compressedValues[repObj.value] = repObj.value;
      this.meta[repObj.value] = {
        appearanceCount: 0
      };
      return;
    }

    this.smartAllocate(repObj.value, repObj.renamedValue);
  }

  smartAllocate(value, renamedValue) {
    // Try to allocate a random compressed name, and if not possible swap with an existing
    // name to avoid conflict and keep compressed name shorter than the initial value
    let randomName = renamedValue || this.nameGenerator.generate(value); // Avoid using an existing or reserved compressed value

    while (this.compressedValues[randomName] || this.isReserved(randomName)) {
      randomName = this.nameGenerator.generate(value);
    }

    this.values[value] = randomName;
    this.meta[value] = {
      appearanceCount: 0
    };
    this.compressedValues[randomName] = value; // Ensure it's optimal (it does not exist in the compressed name already and is shorter
    // than the actual value).
    // Example if not the case: values = {'move':'a'}, compValue = {'a':'move'}
    // allocating new value 'a' for (generated) 'ab'
    // We expect values = {'move': 'ab', 'a': 'a'}, compValue = {'a': 'a', 'ab': 'move'}

    if (this.compressedValues[value] || randomName.length > value.length) {
      this.swap(value, this.compressedValues[value]);
    }
  }

  swap(val1, val2) {
    // swap the compressed value for val1 with the compressed value for val2
    if (!this.values[val1] || !this.values[val2]) {
      return;
    } // Use object destructuring to swap without a temp variable


    [this.values[val1], this.values[val2]] = [this.values[val2], this.values[val1]];
    [this.meta[val1], this.meta[val2]] = [this.meta[val2], this.meta[val1]];
    [this.compressedValues[this.values[val2]], this.compressedValues[this.values[val1]]] = [val2, val1];
  }

  setMultiple(values = {}, options = {}) {
    if (Object.prototype.toString.call(values) !== '[object Object]') {
      return;
    }

    Object.entries(values).forEach(entry => this.set(entry[0], entry[1], options));
  }

  setPrefix(prefix) {
    if (typeof prefix !== 'string') {
      return;
    }

    this.prefix = prefix;
  }

  setSuffix(suffix) {
    if (typeof suffix !== 'string') {
      return;
    }

    this.suffix = suffix;
  }

  setInternalLists(string, listPointer, regexListPointer) {
    if (!string) return;

    if (Array.isArray(string)) {
      string.forEach(e => this.setInternalLists(e, listPointer, regexListPointer));
      return;
    } // todo jpeer: check if failes


    if (listPointer.includes(string) || regexListPointer.includes(string)) {
      return;
    }

    if (string instanceof RegExp) {
      regexListPointer.push(string);
    } else {
      listPointer.push(string);
    }
  }

  setExclude(toExclude) {
    this.setInternalLists(toExclude, this.excludes, this.excludesRegex);
  }

  setInclude(toInclude) {
    this.setInternalLists(toInclude, this.includes, this.includesRegex);
  }

  setReserved(toReserve) {
    if (!toReserve) return;
    this.reserved = [];

    if (!Array.isArray(toReserve)) {
      this.reserved.push(toReserve);
    } else {
      this.reserved = [...new Set(toReserve)];
    }
  }

  isReserved(string) {
    return this.reserved.includes(string);
  }

  isExcluded(string) {
    if (string === '__proto__') {
      // Since this.values['__proto__'] always exists, we mustn't accept this as a renaming
      return true;
    }

    if (this.excludes.includes(string)) {
      if (this.includesRegex.some(includeRegex => string.match(includeRegex))) {
        return false;
      }

      return !this.includes.includes(string);
    }

    return this.excludesRegex.some(excludeRegex => string.match(excludeRegex) && !this.includesRegex.some(includeRegex => string.match(includeRegex)));
  }

}

exports.BaseLibrary = BaseLibrary;
exports.default = new BaseLibrary();