"use strict";

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const parse5_1 = __importDefault(require("parse5"));

const parse5_traverse_1 = __importDefault(require("parse5-traverse"));

const lodash_merge_1 = __importDefault(require("lodash.merge"));

const shouldTriggerAttribute_1 = __importDefault(require("../helpers/shouldTriggerAttribute"));

const selectorsLibrary_1 = __importDefault(require("../selectorsLibrary"));

const js_1 = __importDefault(require("./js"));

const css_1 = __importDefault(require("./css"));

const htmlToAst_1 = __importDefault(require("../helpers/htmlToAst"));

const string_1 = __importDefault(require("./string"));

const replaceHtml = (code, opts = {}) => {
  const defaultOptions = {
    espreeOptions: {},
    triggerClassAttributes: [],
    triggerIdAttributes: []
  };
  const options = (0, lodash_merge_1.default)({}, opts, defaultOptions);
  const ast = (0, htmlToAst_1.default)(code);
  const srcOpt = {
    sourceFile: opts.sourceFile
  };
  (0, parse5_traverse_1.default)(ast, {
    // todo jpeer: check correct type
    pre: node => {
      // rename <script> tags
      if (node.parentNode && node.parentNode.tagName === 'script') {
        const hasAnyAttrs = node.parentNode.attrs.length === 0;
        const hasType = node.parentNode.attrs.some(attr => attr.name === 'type');
        const hasTypeAndJavaScript = node.parentNode.attrs.some(attr => attr.name === 'type' && (attr.value === 'application/javascript' || attr.value === 'module')); // should just go inside if it is either
        // no type
        // type set to application/json || module

        if (hasAnyAttrs || !hasType || hasTypeAndJavaScript) {
          // eslint-disable-next-line no-param-reassign
          node.value = (0, js_1.default)(node.value, (0, lodash_merge_1.default)({}, options.espreeOptions, srcOpt));
        }
      } // rename <noscript> tags


      if (node.parentNode && node.parentNode.tagName === 'noscript') {
        // eslint-disable-next-line no-param-reassign
        node.value = replaceHtml(node.value, opts);
      } // rename <style> tags


      if (node.parentNode && node.parentNode.tagName === 'style') {
        // eslint-disable-next-line no-param-reassign
        node.value = (0, css_1.default)(node.value, srcOpt);
      } // rename attributes


      if (Array.isArray(node.attrs) && node.attrs.length >= 0) {
        node.attrs.forEach(attr => {
          let selectorType;
          const isVueClass = attr.name === 'v-bind:class' || attr.name === ':class';
          const isVueId = attr.name === 'v-bind:id' || attr.name === ':id';

          if (attr.name === 'class' || isVueClass || options.triggerClassAttributes.some(item => (0, shouldTriggerAttribute_1.default)(attr, item))) {
            selectorType = '.';
          }

          if (attr.name === 'id' || isVueId || options.triggerIdAttributes.some(item => (0, shouldTriggerAttribute_1.default)(attr, item))) {
            selectorType = '#';
          }

          if (node.tagName === 'label' && attr.name === 'for') {
            selectorType = '#';
          }

          if (!selectorType) {
            return;
          } // following will replace each whitespace
          // seperated value with its renamed one


          if (isVueClass || isVueId) {
            // eslint-disable-next-line no-param-reassign
            attr.value = attr.value.replace(/'[\s\S]*?'|"[\s\S]*?"/g, match => {
              const replacedString = (0, string_1.default)(match, undefined, {
                forceReplace: true,
                source: {
                  file: opts.sourceFile || '',
                  line: node.sourceCodeLocation.startLine,
                  text: ''
                }
              }); // in case HTML has been written with wrong quotes
              // turn them back as parse5 will serialize it correctly

              return replacedString.replace(/"/g, "'");
            });
          } else {
            // eslint-disable-next-line no-param-reassign
            attr.value = attr.value.split(' ').map(value => // renaming each value
            selectorsLibrary_1.default.get(`${selectorType}${value}`, {
              source: {
                file: opts.sourceFile || '',
                line: node.sourceCodeLocation.startLine,
                text: ''
              }
            }).replace(new RegExp(`^\\${selectorType}`), '')).join(' ');
          }
        });
      }
    }
  });
  return parse5_1.default.serialize(ast);
};

exports.default = replaceHtml;
module.exports = exports.default;