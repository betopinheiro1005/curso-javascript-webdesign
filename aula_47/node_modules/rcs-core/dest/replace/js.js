"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const recast_1 = require("recast");

const ast_traverse_1 = __importDefault(require("ast-traverse"));

const espree = __importStar(require("espree"));

const lodash_merge_1 = __importDefault(require("lodash.merge"));

const selectorsLibrary_1 = __importDefault(require("../selectorsLibrary"));

const string_1 = __importDefault(require("./string"));

const cssVariablesLibrary_1 = __importDefault(require("../cssVariablesLibrary"));

const regex_1 = __importDefault(require("./regex"));

const makeSource = (node, file) => {
  const Position = node.loc.start.constructor;
  const currentLine = node.loc.start.line;
  const sourceLine = node.loc.lines.sliceString(new Position(currentLine, 0), new Position(currentLine, node.loc.lines.getLineLength(currentLine)));
  return {
    file,
    line: currentLine,
    text: sourceLine
  };
};

const replaceJs = (code, espreeOptions = {}) => {
  // We can only use the common regex if we don't care about specific class/id processing
  const regex = selectorsLibrary_1.default.getAllRegex();
  const options = (0, lodash_merge_1.default)({
    ecmaVersion: 'latest',
    sourceType: 'module',
    ecmaFeatures: {
      jsx: true
    }
  }, espreeOptions);
  const ast = (0, recast_1.parse)(code, {
    parser: {
      parse: source => espree.parse(source, Object.assign(Object.assign({}, options), {
        range: true,
        loc: true,
        comment: true,
        attachComment: true,
        tokens: true
      }))
    }
  });
  (0, ast_traverse_1.default)(ast, {
    pre: (node, parentNode) => {
      let isJSX = false; // Avoid recursing into a "in" node since it can't be a CSS class or variable.

      if (node.type === 'BinaryExpression' && node.operator === 'in') {
        return false;
      } // check if parent is JSXAttribute


      if (parentNode && parentNode.type === 'JSXAttribute' && ['class', 'id', 'for'].includes(parentNode.name.name)) {
        isJSX = true;
      }

      if (node.type === 'TemplateElement' && 'raw' in node.value) {
        const source = makeSource(node, options.sourceFile);
        const raw = node.value.raw.replace(regex_1.default.templateSelectors, (txt, p1, p2, p3) => {
          // p3 contains the content of the class=' or id=", so let's replace them
          const newValue = ` ${p3} `;
          const selectorLib = p1 === 'class' ? selectorsLibrary_1.default.getClassSelector() : selectorsLibrary_1.default.getIdSelector();
          const selectorLibRegex = selectorLib.getAll({
            regex: true
          });

          if (!(selectorLibRegex instanceof RegExp)) {
            return newValue;
          }

          const replacedAttr = newValue.replace(newValue, match => (0, string_1.default)(match, selectorLibRegex, // don't be too smart about selector detection and non replacement if we have
          // a class, since class="a b" should replace both entry here even if it looks like
          // a selector text for parent child tags
          {
            isJSX,
            classOnly: p1 === 'class',
            countStats: false,
            source
          }));
          return `${p1}=${p2 + replacedAttr.slice(1, replacedAttr.length - 1) + p2}`;
        }); // eslint-disable-next-line no-param-reassign

        node.value.raw = raw;
      } else if (node.type === 'Literal' && typeof node.value === 'string') {
        const source = makeSource(node, options.sourceFile); // eslint-disable-next-line no-param-reassign

        node.raw = node.raw.replace(node.raw, match => (0, string_1.default)(match, regex, {
          isJSX,
          source
        })); // add whitespaces before and after
        // to make the regex work

        const newValue = ` ${node.value} `; // replace css selectors

        const replacedCssSelectors = newValue.replace(newValue, match => (0, string_1.default)(match, regex, {
          isJSX,
          countStats: false,
          source
        })); // replace css variables

        const replacedCssVariables = replacedCssSelectors.replace(regex_1.default.cssVariables, match => cssVariablesLibrary_1.default.get(match, {
          source
        })); // eslint-disable-next-line no-param-reassign

        node.value = replacedCssVariables.slice(1, replacedCssVariables.length - 1);
      }

      return true;
    }
  });
  return (0, recast_1.print)(ast).code;
};

exports.default = replaceJs;
module.exports = exports.default;